use ndarray::arr2;
use ndarray::Array2;
use petgraph::graph::DiGraph;

struct SPTree {
    t: Vec<(u32, u32)>,
    l: Vec<(u32, u32)>,
    u: Vec<(u32, u32)>,
}

fn main() {
    //Graph definition
    let mut graph = DiGraph::new();
    let root = graph.add_node("root");
    let n1 = graph.add_node("1");
    let n2 = graph.add_node("2");
    let t = graph.add_node("sink");
    graph.add_edge(root, n1, 10);
    graph.add_edge(root, n2, 10);
    graph.add_edge(n2, n1, 10);
    graph.add_edge(n2, t, 10);
    graph.add_edge(n1, t, 10);
    graph.add_edge(root, t, 10);

    //Flow capacities and costs
    let mut x = arr2(&[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]);

    let c = arr2(&[[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]);

    let u = arr2(&[
        [0, 10, 10, 10],
        [10, 0, 10, 10],
        [10, 10, 0, 10],
        [10, 10, 10, 0],
    ]);

    initialization(graph, x, u, c);
}

fn initialization<N, E>(graph: DiGraph<N, E>, x: Array2<u32>, u: Array2<u32>, c: Array2<u32>) -> SPTree {
    let mut T:Vec<(u32, u32)> = Vec::new();
    let mut L:Vec<(u32, u32)> = Vec::new();
    let mut U:Vec<(u32, u32)> = Vec::new();



    SPTree {
        t: T,
        l: L,
        u: U,
    }
    
}

struct PRstruct {
    capacity: Array2<u32>,
    flow: Array2<u32>,
    label: Vec<u32>,
    excess: Vec<u32>,
    excess_vertices: Vec<u32>,
    seen: Vec<u32>,
}
//Push-Relabel algorithm
fn push(u, v, g:PRstruct) -> PRstruct  {
    let d = std::cmp::min(g.excess[u], g.capacity[u][v] - g.flow[u][v]); 
}

fn relabel() {
    
}

fn discharge() {
    
}

fn max_flow() {
    
}
